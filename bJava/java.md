## int long char

> int 32位 4个字节 范围： ox8000_0000 ~ ox7FFF_FFFF
> byte 1字节
> boolean 1字节
> short 2字节
> char 2字节
> int 4字节
> float 4字节
> long 8字节
> double 8字节 
##Stack和Heap的区别 [链接](https://www.cnblogs.com/songanwei/p/9386418.html)

> 要点：**堆**，队列优先,先进先出（FIFO—first in first out）。
> 
>    **栈**，先进后出(FILO—First-In/Last-Out)。

> 一、堆栈空间分配区别：
> 
　　2、**堆**（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。
> 
　　1、**栈**（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；

> 二、堆栈缓存方式区别：
> 
　 2、堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。
> 
　 1、栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放； 
>
三、堆栈数据结构区别：
>
　　**堆**（数据结构）：堆可以被看成是一棵树，如：堆排序； 
>
　　**栈**（数据结构）：一种先进后出的数据结构。

>
栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 
>
　　在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。 
>　　
   堆内存用来存放由new创建的对象和数组，在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。 
>
Java中变量在内存中的分配： 
>
　　1、类变量（static修饰的变量）：在程序加载时系统就为它在堆中开辟了内存，堆中的内存地址存放于栈以便于高速访问。静态变量的生命周期–一直持续到整个”系统”关闭。 
>
　　2、实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量（比如说类实例），然后根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”。 实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存。 
>
　3、局部变量：局部变量，由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放。 

##Java 内存机制:

> Java 把内存划分成两种：一种是栈内存，另一种是堆内存。 
>
>　在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java 会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。 
>
>　堆内存用来存放由 new 创建的对象和数组，在堆中分配的内存，由 Java 虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组或者对象之后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或者对象，引用变量就相当于是为数组或者对象起的一个名称。引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序运行到使用 new 产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能在被使用，但仍然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放掉）。

##java中常用的内存区域

>在java中主要存在4块内存空间，这些内存的名称及作用如下： 
>
>  1.栈内存空间：保存所有的对象名称（更准确地说是保存了引用的堆内存空间的地址） 
>
>　2.堆内存空间：保存每个对象的具体属性内容。 
>
>　3.全局数据区：保存static类型的属性。 
>
>　4.全局代码区：保存所有的方法定义。

##[Java虚拟机（JVM）你只要看这一篇就够了！](https://blog.csdn.net/qq_41701956/article/details/81664921)



## hash

### ***hash***值不同的数据类型通过不同的hash算法就算出一个短的唯一值

  **String** 的hashCode（）
	
	 public int hashCode() {
        int h = hash;
        final int len = length();
        if (h == 0 && len > 0) {
            for (int i = 0; i < len; i++) {
                h = 31 * h + charAt(i);
            }
            hash = h;
        }
        return h;
    }
###hashMap
	put(key，value)方法 返回值为map中key的value值（如果存在则返回已存在的值，并存入新值，不存在返回null）

	Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类

	hashtable 不允许null ，hashmap允许null
	
 1. 存储结构
	 1. hashmap底层以数组形式进行存储，将key-value对作为数组中的一个元素进行存储
	 2. key-value都是Map.Entry中的属性其中将key的值进行hash之后进行存储，即每个key都是计算hash值，然后再存储。每个hash值对应一个数组下标，数组下标是根据hash值和数组长度计算得来，
	 3. 由于不同的key有可能hash值相同，即该位置的数组中的元素出现两个，对于这种情况，hashmap采用链表形式进行存储。（key的hash值相同， key不同）
	 4. hash碰撞解决：
		1. 开放地址 当发生地址冲突时，按住某种方法继续谈猜测哈希表中的其他存储单元，知道找到空缺位置为止
		2. rehash ，使用第二个或第三个  计算地址，直到无冲突，eg：按首字母进行了hash冲突了，则再按照首字母第二位，进行hash寻址。
		3. ***链地址法（拉链法）*** **hashmap使用的此方法**
			1. 创建一个链表数组，数组中的每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。
			2. jdk1.8之后采用数组+链表+红黑树的数据结构
		4. 红黑树（jdk1.8）当链表长度>8时
		5. 链表时间复杂度 O(n)  红黑树的时间复杂度 O(logn)
	
	 >通过hash(key)%len存储到相对应的数组中，如140%16=12.意味着数组下标相同，并不表示hashCode相同。

     
	>而且红黑树的优点是对于有序数据的操作不会慢到O(N)的时间复杂度

	

 2. 默认加载因子 0.75 默认大小16
 3. hashmap线程不安全
	 > 1. 当用在方法内的局部变量时，局部变量属于当前线程级别的变量，其他线程访问不了，所以这时也不存在线程安全的问题了。 
	 > 2. 当用在单例对象成员变量里的时候， 这时候多个线程过来访问的就是同一个HashMap了，对同一个HashMap操作这时候就存在线程安全的问题了。--**线程不安全**
	 > 3. hashmap 以 Map.Entry形式存储， Entry 是单项非循环链表
	 1. --put-addEntry-createEntry都是线程不安全的操作。
	 2. hashmap扩容时resize() 也是线程不安全的。

 4. 安全的map
	 1. HashTable
		 1. HashTable的put\get方法都是被synchronized关键字修饰，在方法级别阻塞，他们占用**共享资源锁**，
		 2. SynchronizedMap :HashMap对象进行了包装同步而已，每次对HashMap的操作都要先获取这个mutex的对象锁才能进入
		 3. ConcurentHashMap-推荐
			每次对HashMap的操作都要先获取这个mutex的对象锁才能进入
 5. 红黑树-是平衡树 ，
	
	1. 
	> 1. ***每个节点不是红色就是黑色***
	 
	>2. ***根节点总是黑色的***
	> 3. ***如果节点是红色，则它的子节点必须是黑色（反之不一定），（也就是说从每个叶子到根的所有路径上不能有两个连续的红色节点）***
	>4. ***从根节点到叶子节点或者空子节点的每条路径，必须包含相同数目的黑色节点***

	2. 红黑树的自我修正
		1. 改变颜色
		2. 左旋
		3. 右旋

	3. 插入和删除操作时间复杂度要比一般的二叉树要慢（多了常数因子，虽然计算复杂度的时候去掉了）
	4. 但是红黑谁 查询的时候速度会很快，
	5. ***优点： 对于有序的数据的操作不会曼岛O(N)的时间复杂度***

	

	

	
	
	


